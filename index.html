<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>互补色及明度阶梯变化</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    .controls {
      margin-bottom: 20px;
    }
    .controls label {
      margin-right: 10px;
    }
    .controls input[type="text"] {
      width: 100px;
      padding: 4px;
      margin-right: 10px;
    }
    .color-box {
      width: 120px;
      height: 120px;
      margin: 10px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      border-radius: 4px;
      flex-direction: column;
    }
    .color-info {
      text-align: center;
      font-size: 14px;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <h1>互补色及明度阶梯变化</h1>
  <div class="controls">
    <label for="colorInput">选择颜色：</label>
    <input type="color" id="colorInput" value="#33AAFF">
    <label for="hexInput">或输入颜色：</label>
    <input type="text" id="hexInput" placeholder="#33AAFF" value="#33AAFF">
    <button id="updateBtn">更新</button>
  </div>
  <div id="colors"></div>

  <script>
    // 将十六进制颜色转换为 RGB 对象
    function hexToRgb(hex) {
      hex = hex.replace(/^#/, '');
      if (hex.length === 3) {
        hex = hex.split('').map(c => c + c).join('');
      }
      const bigint = parseInt(hex, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return { r, g, b };
    }

    // 将 RGB 转换为十六进制颜色字符串
    function rgbToHex(r, g, b) {
      const toHex = c => {
        const hex = c.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }
      return '#' + toHex(r) + toHex(g) + toHex(b);
    }

    // RGB 转 HSL（h,s,l 均在 [0,1] 范围内）
    function rgbToHsl(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h, s;
      const l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return { h, s, l };
    }

    // HSL 转 RGB
    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
    }

    // 计算互补色：仅旋转色相 180°（加 0.5），保持饱和度和明度不变
    function getComplementaryColor(hex) {
      const { r, g, b } = hexToRgb(hex);
      let { h, s, l } = rgbToHsl(r, g, b);
      h = (h + 0.5) % 1;
      const { r: compR, g: compG, b: compB } = hslToRgb(h, s, l);
      return { color: rgbToHex(compR, compG, compB), lBase: l, h, s };
    }

    /**
     * 根据预设阶梯系数，生成一组互补色的明度变化。
     * 这里定义了系数数组，比如 [-0.4, -0.2, 0, 0.2, 0.4]，表示基于互补色原明度的调整：
     * 负值使颜色变暗，正值使颜色变亮，0 为基础互补色
     */
    function getComplementaryColorsWithCoefficients(hex) {
      // 先计算互补色及其基础明度
      const comp = getComplementaryColor(hex);
      const { h, s, lBase } = comp;
      // 定义明度调整系数（可根据需要调整）
      const coefficients = [-0.4, -0.2, 0, 0.2, 0.4];
      const colors = [];
      coefficients.forEach(coef => {
        // 调整后的明度，注意控制在 [0,1] 范围内
        const newL = Math.max(0, Math.min(1, lBase + coef));
        const { r, g, b } = hslToRgb(h, s, newL);
        colors.push({
          color: rgbToHex(r, g, b),
          coeff: coef
        });
      });
      return colors;
    }

    // 创建颜色块的 DOM 元素，label 中注明阶梯系数（当 coef 为 0 时标记为“基准”）
    function createColorBox(color, label, coeff = null) {
      const box = document.createElement('div');
      box.className = 'color-box';
      box.style.backgroundColor = color;
      let coeffText = '';
      if (coeff !== null) {
        coeffText = (coeff === 0) ? '（基准）' : `（${coeff > 0 ? '+' : ''}${coeff}）`;
      }
      box.innerHTML = `<div class="color-info">${label}${coeffText}<br>${color}</div>`;
      return box;
    }

    // 更新页面上的颜色展示
    function updateColors() {
      let hex = document.getElementById('hexInput').value.trim();
      if (hex && hex[0] !== '#') {
        hex = '#' + hex;
      }
      // 简单验证颜色格式（支持3位或6位16进制）
      if (!/^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/.test(hex)) {
        alert('请输入有效的颜色代码，例如：#33AAFF');
        return;
      }
      // 同步更新颜色选择器
      document.getElementById('colorInput').value = hex;

      const container = document.getElementById('colors');
      container.innerHTML = '';

      // 渲染原色
      container.appendChild(createColorBox(hex, '原色'));

      // 先计算基础互补色
      const baseComp = getComplementaryColor(hex);
      container.appendChild(createColorBox(baseComp.color, '互补色', 0));

      // 渲染带有明度阶梯系数的互补色
      const compSet = getComplementaryColorsWithCoefficients(hex);
      compSet.forEach((item, index) => {
        // index 用于区分各阶梯，但 label 中会显示具体的系数
        container.appendChild(createColorBox(item.color, `阶梯 ${index + 1}`, item.coeff));
      });
    }

    // 事件绑定
    document.getElementById('updateBtn').addEventListener('click', updateColors);
    document.getElementById('colorInput').addEventListener('input', function() {
      const hex = this.value;
      document.getElementById('hexInput').value = hex;
      updateColors();
    });

    // 页面初次加载时更新一次
    updateColors();
  </script>
</body>
</html>
